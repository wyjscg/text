use serde::{Deserialize, Serialize};
use k8s_openapi::apimachinery::pkg::apis::meta::v1 as metav1;
use k8s_openapi::apimachinery::pkg::types;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PodCertificateRequest {
    #[serde(flatten)]
    pub type_meta: metav1::TypeMeta,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<metav1::ObjectMeta>,

    pub spec: PodCertificateRequestSpec,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<PodCertificateRequestStatus>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PodCertificateRequestSpec {
    pub signer_name: String,

    pub pod_name: String,

    pub pod_uid: types::UID,

    pub service_account_name: String,

    pub service_account_uid: types::UID,

    pub node_name: types::NodeName,

    pub node_uid: types::UID,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_expiration_seconds: Option<i32>,

    pub pkix_public_key: Vec<u8>,

    pub proof_of_possession: Vec<u8>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub unverified_user_annotations: Option<std::collections::HashMap<String, String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PodCertificateRequestStatus {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<metav1::Condition>>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_chain: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub not_before: Option<metav1::Time>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub begin_refresh_at: Option<metav1::Time>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub not_after: Option<metav1::Time>,
}
