use std::collections::HashMap;

pub trait Node {
    fn id(&self) -> i64;
}

pub trait Edge {
    fn from(&self) -> &dyn Node;
    fn to(&self) -> &dyn Node;
}

pub trait EdgeHolder {
    fn visit(&self, visitor: &mut dyn FnMut(i64, &dyn Edge));

    fn delete(self: Box<Self>, neighbor: i64) -> Box<dyn EdgeHolder>;

    fn set(self: Box<Self>, neighbor: i64, edge: Box<dyn Edge>) -> Box<dyn EdgeHolder>;

    fn get(&self, neighbor: i64) -> Option<&dyn Edge>;

    fn len(&self) -> usize;
}

pub struct SliceEdgeHolder {
    self_id: i64,
    edges: Vec<Box<dyn Edge>>,
}

impl SliceEdgeHolder {
    pub fn new(self_id: i64) -> Self {
        SliceEdgeHolder {
            self_id,
            edges: Vec::new(),
        }
    }
}

impl EdgeHolder for SliceEdgeHolder {
    fn visit(&self, visitor: &mut dyn FnMut(i64, &dyn Edge)) {
        for edge in &self.edges {
            if edge.from().id() == self.self_id {
                visitor(edge.to().id(), edge.as_ref());
            } else {
                visitor(edge.from().id(), edge.as_ref());
            }
        }
    }

    fn delete(mut self: Box<Self>, neighbor: i64) -> Box<dyn EdgeHolder> {
        self.edges.retain(|edge| {
            if edge.from().id() == self.self_id {
                edge.to().id() != neighbor
            } else {
                edge.from().id() != neighbor
            }
        });
        self
    }

    fn set(mut self: Box<Self>, neighbor: i64, new_edge: Box<dyn Edge>) -> Box<dyn EdgeHolder> {
        for edge in &mut self.edges {
            if edge.from().id() == self.self_id {
                if edge.to().id() == neighbor {
                    *edge = new_edge;
                    return self;
                }
            } else {
                if edge.from().id() == neighbor {
                    *edge = new_edge;
                    return self;
                }
            }
        }

        if self.edges.len() < 4 {
            self.edges.push(new_edge);
            return self;
        }

        let mut h: HashMap<i64, Box<dyn Edge>> = HashMap::with_capacity(self.edges.len() + 1);
        for edge in self.edges {
            if edge.from().id() == self.self_id {
                h.insert(edge.to().id(), edge);
            } else {
                h.insert(edge.from().id(), edge);
            }
        }
        h.insert(neighbor, new_edge);
        Box::new(MapEdgeHolder { edges: h })
    }

    fn get(&self, neighbor: i64) -> Option<&dyn Edge> {
        for edge in &self.edges {
            if edge.from().id() == self.self_id {
                if edge.to().id() == neighbor {
                    return Some(edge.as_ref());
                }
            } else {
                if edge.from().id() == neighbor {
                    return Some(edge.as_ref());
                }
            }
        }
        None
    }

    fn len(&self) -> usize {
        self.edges.len()
    }
}

pub struct MapEdgeHolder {
    edges: HashMap<i64, Box<dyn Edge>>,
}

impl MapEdgeHolder {
    pub fn new() -> Self {
        MapEdgeHolder {
            edges: HashMap::new(),
        }
    }

    pub fn with_capacity(capacity: usize) -> Self {
        MapEdgeHolder {
            edges: HashMap::with_capacity(capacity),
        }
    }
}

impl EdgeHolder for MapEdgeHolder {
    fn visit(&self, visitor: &mut dyn FnMut(i64, &dyn Edge)) {
        for (&neighbor, edge) in &self.edges {
            visitor(neighbor, edge.as_ref());
        }
    }

    fn delete(mut self: Box<Self>, neighbor: i64) -> Box<dyn EdgeHolder> {
        self.edges.remove(&neighbor);
        self
    }

    fn set(mut self: Box<Self>, neighbor: i64, edge: Box<dyn Edge>) -> Box<dyn EdgeHolder> {
        self.edges.insert(neighbor, edge);
        self
    }

    fn get(&self, neighbor: i64) -> Option<&dyn Edge> {
        self.edges.get(&neighbor).map(|e| e.as_ref())
    }

    fn len(&self) -> usize {
        self.edges.len()
    }
}
