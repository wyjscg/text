use std::sync::Mutex;
use std::time::Instant;

impl Graph {
    pub fn add_pod_certificate_request(&self, pcr: &certsv1beta1::PodCertificateRequest) {
        let start = Instant::now();
        
        let _guard = self.record_action_duration("AddPodCertificateRequest", start);
        
        let mut graph = self.lock.lock().unwrap();
        
        graph.delete_vertex_locked(
            VertexType::PodCertificateRequest,
            &pcr.metadata.as_ref().map(|m| m.namespace.clone()).unwrap_or_default(),
            &pcr.metadata.as_ref().map(|m| m.name.clone()).unwrap_or_default(),
        );
        
        let pcr_vertex = graph.get_or_create_vertex_locked(
            VertexType::PodCertificateRequest,
            &pcr.metadata.as_ref().map(|m| m.namespace.clone()).unwrap_or_default(),
            &pcr.metadata.as_ref().map(|m| m.name.clone()).unwrap_or_default(),
        );
        
        let node_vertex = graph.get_or_create_vertex_locked(
            VertexType::Node,
            "",
            &pcr.spec.as_ref()
                .map(|s| s.node_name.clone())
                .unwrap_or_default(),
        );
        
        graph.add_edge_locked(&pcr_vertex, &node_vertex, &node_vertex);
    }

    pub fn delete_pod_certificate_request(&self, pcr: &certsv1beta1::PodCertificateRequest) {
        let start = Instant::now();
        
        let _guard = self.record_action_duration("DeletePodCertificateRequest", start);
        
        let mut graph = self.lock.lock().unwrap();
        
        graph.delete_vertex_locked(
            VertexType::PodCertificateRequest,
            &pcr.metadata.as_ref().map(|m| m.namespace.clone()).unwrap_or_default(),
            &pcr.metadata.as_ref().map(|m| m.name.clone()).unwrap_or_default(),
        );
    }
    
    fn record_action_duration(&self, action: &str, start: Instant) -> impl Drop {
        struct Guard {
            action: String,
            start: Instant,
        }
        
        impl Drop for Guard {
            fn drop(&mut self) {
                let duration = self.start.elapsed().as_secs_f64();
                GRAPH_ACTIONS_DURATION
                    .with_label_values(&[&self.action])
                    .observe(duration);
            }
        }
        
        Guard {
            action: action.to_string(),
            start,
        }
    }
}
